{"data":{"wordpressPost":{"title":"Constructing 3D Polyhedra in Abaqus using Python scripting","content":"<html><head></head><body><p><a href=\"https://gist.github.com/jphungcode/9d3117a68cb1b906b66b362872a8c594\" target=\"_blank\" rel=\"noopener noreferrer\">Colab Notebook here</a></p>\n<p>If you&#x2019;re into heterogeneous modelling then you might&#x2019;ve come across constructing a 3D polygon with random vertices. In my context, constructing such a model was to investigate mesoscale effects in a concrete material (made up of coarse and fine aggregates). Regardless, this methodology of using Abaqus and Python to construct a polyhedra is applicable cross-discipline.</p>\n<p><div class=\" gatsby-image-wrapper\" style=\"position:relative;overflow:hidden;max-width:100%\" data-reactroot><div style=\"width:100%;padding-bottom:50%\"></div><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACbElEQVQoz3WS2U8TURjF5w8xPkBQiZGaKCiKiIlbKgIFbXjAgP4FJBpIjC+aCDYKSkQWrZgIYmIotUB3oPLgWgudQgvUsnWh20xLWwUsD8evl0afnOSXM/fck5M7cz+Ot/PgZ+ywffsC3sHDwfNYmHfBvbiApSUPFhfn4XTOMTzuBXh+uOHzrsGgH0Nrawset7ejre0RQ6F4AE6v18NkMMJiscBkHofZaMKw+j3eDQ1BqzdBNawmNWNEa8CoZgQajQYq9TAMRi3GJz8QU0zNExYGFwoFsR4MYnllBeGgH8+Vvdh37DL2H/9H4Vk5JKXV2CM5h72HL+BAcSXL5BVeQl4RUShFfkk1y3LpnR1EIhH4AwGkf2/iZZ8SOUek2dIK5ByVoqyiHvcfdhBPIb/RiFwqyKUyVpqhqBwFZ2qRf1IGbnt7mxV6vV4kNuJQvnqNgyU1kJy+igJCUiZH/gkZii/WoaNLic8fp3CvtY387H42d+hUDQpKr4Db2tpCNBLGRiKBzV8p9A++Rfm1W6hqaEJlhvomyK43M+98bSPutHRCp9Pi9l0FpHU3UUV7mVxVQzODS1LRsseNZDKFjbiICcskuvpH0TMwhu43WnRntXdQhx7iSZ8aLwZHMaDSUW6EGGP5Z0QnwX2iT7BNT8PhcNBouDA352TvdrsdPI2Q0+nE7Ozs33WQLjAqiAiFo6TCLlEiFoPL4wH33foVPp8P6+sBBOhi/H4/AoSXvMw6HA6zEr9v10+n0/jfI1I5Z7XaaICXGKtrqwiFQkilfiKZECGKUYI0JkKICYjRKTIIYuZ0UQhC1ovH6ZclWccf8vVXVfUuaA4AAAAASUVORK5CYII=\" alt style=\"position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;object-position:center;opacity:1;transition:opacity 0.5s;transition-delay:0.25s\"><picture><img sizes=\"(max-width: 640px) 100vw, 640px\" srcset=\"/static/426f2b38870fa85a228d92d4b01a9b98/5039d/abaqus-screenshot.png 250w,\n/static/426f2b38870fa85a228d92d4b01a9b98/d19c0/abaqus-screenshot.png 500w,\n/static/426f2b38870fa85a228d92d4b01a9b98/e49a9/abaqus-screenshot.png 640w\" src=\"/static/426f2b38870fa85a228d92d4b01a9b98/e49a9/abaqus-screenshot.png\" alt style=\"position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;object-position:center;opacity:1;transition:opacity 0.5s\"></picture><noscript><picture><img sizes=\"(max-width: 640px) 100vw, 640px\" srcset=\"/static/426f2b38870fa85a228d92d4b01a9b98/5039d/abaqus-screenshot.png 250w,\n/static/426f2b38870fa85a228d92d4b01a9b98/d19c0/abaqus-screenshot.png 500w,\n/static/426f2b38870fa85a228d92d4b01a9b98/e49a9/abaqus-screenshot.png 640w\" src=\"/static/426f2b38870fa85a228d92d4b01a9b98/e49a9/abaqus-screenshot.png\" alt=\"\" style=\"position:absolute;top:0;left:0;transition:opacity 0.5s;transition-delay:0.5s;opacity:1;width:100%;height:100%;object-fit:cover;object-position:center\"/></picture></noscript></div></p>\n<h4>Getting Started</h4>\n<p>To get started, you will need a set of polygon vertex coordinates and its convex hull, which you can download <a href=\"https://https://github.com/jphungcode/abaqus-polyhedra\">here</a>.</p>\n<p>For a bit of background on my workflow, I&#x2019;ve generated random vertices for the polyhedra and determined the convex hull using Matlab (convhull function).</p>\n<p>In this generation script, I&#x2019;m reading from the csv file, which constitutes to one polyhedra dataset, then using Abaqus methods which can be determined from recording macro to programmatically create the geometry.</p>\n<pre class=\"line-numbers\"><code class=\"language-python\">from abaqus import *\nfrom abaqusConstants import *\nimport numpy as np\nimport os\nimport __main__\n\nimport section\nimport regionToolset\nimport displayGroupMdbToolset as dgm\nimport part\nimport material\nimport assembly\nimport step\nimport interaction\nimport load\nimport mesh\nimport optimization\nimport job\nimport sketch\nimport visualization\nimport xyPlot\nimport displayGroupOdbToolset as dgo\nimport connectorBehavior\n\ncsvPath = r&quot;/path&quot; #path storing the polygon data\nos.chdir(csvPath)\n\ndata = [];\nconvexHull = [];\ndata = np.genfromtxt(&apos;polygon1.csv&apos;, delimiter=&apos;,&apos;)\nconvexHull = np.genfromtxt(&apos;polygon1-hull.csv&apos;, delimiter=&apos;,&apos;)</code></pre>\n<h4>Procedure</h4>\n<p>Once we have imported the Abaqus modules and loaded the polygon data in, we can now start drawing the 3D polygon. The general procedure is as follows:</p>\n<ol>\n<li>Create datum points which represent each polygon vertex (Part &gt; Datum Point)</li>\n<li>Join datum points with a wire line (Shape &gt; Wire &gt; Point to Point) by following the convex hull configuration</li>\n<li>Each wire line represents an edge, and 3 edges which forms a triangle can be converted to a face. To do this (Tools &gt; Geometry Edit &gt; Face &gt; Cover Edges &gt; select 3 edges that enclose the face)</li>\n<li>Convert all wire lines into faces</li>\n<li>Select all faces and convert it to a solid (Shape &gt; Solid &gt; From shell &gt; Select all faces)</li>\n</ol>\n<h4>Create Vertices using Datum Points</h4>\n<p>Now, let&#x2019;s have a look at the python code to script this.</p>\n<pre class=\"line-numbers\"><code class=\"language-python\"># create coordinate reference and supress\np = mdb.models[&apos;Model-1&apos;].Part(name=&apos;Part-1&apos;, dimensionality=THREE_D, type=DEFORMABLE_BODY)\np.ReferencePoint(point=(0.0, 0.0, 0.0))\t\np.features[&apos;RP&apos;].suppress()\n\nfor item in data:\n\tp.DatumPointByCoordinate(coords=(item[0], item[1], item[2]))\n\t\nd1 = p.datums;</code></pre>\n<p>In the code above, we created a part with the default name &#x201C;Part-1&#x201D;, then created a reference point to initalise a 3D space to sketch in. After that, using DatumPointByCoordinate which is a method which creates datum points, we create all the vertices from the variable data by looping through it.</p>\n<h4>Create Edges using Wires</h4>\n<p>Next part of the code is to loop through the newly created datum points and join them up using wire lines. To determine which datum points to join in order, we need to refer to the convex hull. The convexHull data is already assigned in the first block of code.</p>\n<pre class=\"line-numbers\"><code class=\"language-python\"># join datum for edges\nfor hull in convexHull:\n\tp.WirePolyLine(points=((d1[int(hull[0])+1], d1[int(hull[1])+1]),), mergeType=IMPRINT, meshable=ON)\n\tp.WirePolyLine(points=((d1[int(hull[1])+1], d1[int(hull[2])+1]),), mergeType=IMPRINT, meshable=ON)\n\tp.WirePolyLine(points=((d1[int(hull[2])+1], d1[int(hull[0])+1]),), mergeType=IMPRINT, meshable=ON)\n\t\neg = p.edges</code></pre>\n<p>p.wirePolyLine is the method to draw a wireline, and we&#x2019;re joining datum points for all possible combinations for each row provided in the convex hull data. For example: A triangle is represented as (P1, P2, P3). To draw this triangle, we need a line between P1 and P2, P2 and P3 and finally P1 and P3.</p>\n<p>An edge is automatically created for each wire line drawn, and we can access that array of edges by calling p.edges, where p is the model part variable name defined earlier.</p>\n<h4>Create Faces from Three Edges</h4>\n<p>Next is to specify the necessary edges to form a face. Since we&#x2019;re dealing with triangles, we need 3 edges. Now this section took some thinking.</p>\n<p>You would think that the order of edges in the edges array corresponds to the order in which the wire lines were created, but it&#x2019;s not &#x2013; which means that you can&#x2019;t simply loop over the edges array (eg) and take every 3 edges sequentially.</p>\n<p>The edges array denoted by variable <strong>eg</strong> returns an array of edges with random ordering of wires and a coordinate that lies on the edge, therefore just using this raw data, you cannot determine which edges you need to construct a face.</p>\n<p>Luckily, by using coordinate founds in each object in the edges array <strong>eg</strong> you can determine which edge it belongs to, by proving its collinearity between two datum points, thus allowing us to loop over the convex hull array and select the right ordering of edges to create a face.</p>\n<pre class=\"line-numbers\"><code class=\"language-python\"># create faces\nfor p in convexHull:\n\tseq = []\n\twireSet = []\n\tfor edge in eg:\n\t\tpoint = edge.pointOn[0]\n\t\tif isCollinear(point, d1[int(p[0])+1].pointOn,d1[int(p[1])+1].pointOn):\t\n\t\t\tif checkWire(1,wireSet):\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tseq.append(edge)\n\t\t\t\twireSet.append(1)\n\t\tif isCollinear(point, d1[int(p[1])+1].pointOn,d1[int(p[2])+1].pointOn):\n\t\t\tif checkWire(2,wireSet):\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tseq.append(edge)\n\t\t\t\twireSet.append(2)\n\t\tif isCollinear(point, d1[int(p[2])+1].pointOn,d1[int(p[0])+1].pointOn):\n\t\t\tif checkWire(3,wireSet):\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tseq.append(edge)\n\t\t\t\twireSet.append(3)\n\t\tif len(seq) == 3:\n\t\t\tp = mdb.models[&apos;Model-1&apos;].parts[&apos;Part-1&apos;]\n\t\t\tp.CoverEdges(edgeList = seq, tryAnalytical=True)\n\t\t\tbreak\n</code></pre>\n<h4>Create a Solid</h4>\n<p>Once you have defined all faces that is fully enclosed, you can simply convert the shell faces into a solid.</p>\n<pre class=\"line-numbers\"><code class=\"language-python\">p = mdb.models[&apos;Model-1&apos;].parts[&apos;Part-1&apos;]\nf = p.faces\np.AddCells(faceList = f)</code></pre>\n<h4>Summary</h4>\n<p>There you have it, I have described the entire Abaqus to construct a 3D polygon programmatically using Python scripting. You can now extend this to the creation of many more 3D polygons for more advanced models.</p>\n<p>Note: I previously have found that the construction of faces from edges not working for datum points / edges points that are really close together (in less than 1mm scale) . To ensure it works properly, I would try avoid polygon vertices&#xA0; that are clustered too close together.</p>\n</body></html>","date":"2019-06-08T03:25:34.000Z","slug":"constructing-3d-polyhedra-in-abaqus-using-python-scripting","acf":{"readingDuration":"6 min","gist_text":""},"categories":[{"name":"Article"}],"featured_media":{"localFile":{"childImageSharp":{"fluid":{"src":"/static/19fdba4ad5c8d6f0278574f6c12f33ca/6d13b/abaqus-polyhedra-01.jpg"}}}}},"site":{"siteMetadata":{"title":"JOHN PHUNG","description":"Researcher, Designer, Developer & Entrepreneur","author":"John Phung","url":"https://johnphung.tech","twitterHandle":"@jphungme"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"7ab79663-150a-5396-b06d-1665f7a19203"}}