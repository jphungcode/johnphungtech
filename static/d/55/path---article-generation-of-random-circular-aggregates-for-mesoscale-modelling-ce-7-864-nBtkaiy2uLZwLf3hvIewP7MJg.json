{"data":{"wordpressPost":{"title":"Generation of Random Circular Aggregates for Mesoscale Modelling","content":"<html><head></head><body><p>Concrete is a four phase material comprising of cement, sand, aggregate and voids. In order to better represent the complexity of concrete material, a mesoscale modelling approach is normally considered which attempts to capture the dominant material structure whilst ignoring finer details. For example, there will be a limitation to the minimum particle size and packing of particles considered in the model due to computational reasons.</p>\n<p>To begin considering heterogeneous concrete models for simulation, you would normally start with circles (2D) or spheres (3D) to represent the aggregate before moving on to ellipse and polygon type aggregates. In order to accurately represent concrete as a mesoscale model, the gradation of particles/sieve distribution needs to be considered and implemented in the generation algorithm. The sieve distribution would either come from your experiment or adapted from literature.</p>\n<h4>Size distribution of aggregates and pores</h4>\n<p>The distribution of particles or gradation is often determined by the fuller curve [1].<br>\n</p><div class=\" gatsby-image-wrapper\" style=\"position:relative;overflow:hidden;max-width:100%;width:300px\" data-reactroot><div style=\"width:100%;padding-bottom:10.714285714285714%\"></div><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMABJPgAAST4AGIAg1vAAAAOElEQVQI12NgYGAQBGI+IGYGYn4gFgZiDiibAypODACp42GAGiACxJxQw2WAWB4qzs1APGAB6QcAZN8BJco3TWYAAAAASUVORK5CYII=\" alt style=\"position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;object-position:center;opacity:1;transition:opacity 0.5s;transition-delay:0.25s\"><picture><img sizes=\"(max-width: 300px) 100vw, 300px\" srcset=\"/static/eeebed5885129f74716619d44de5d9bb/c14e1/post3_eq1.png 75w,\n/static/eeebed5885129f74716619d44de5d9bb/d4214/post3_eq1.png 150w,\n/static/eeebed5885129f74716619d44de5d9bb/135ae/post3_eq1.png 300w,\n/static/eeebed5885129f74716619d44de5d9bb/44727/post3_eq1.png 450w,\n/static/eeebed5885129f74716619d44de5d9bb/34e8a/post3_eq1.png 600w,\n/static/eeebed5885129f74716619d44de5d9bb/576cc/post3_eq1.png 896w\" src=\"/static/eeebed5885129f74716619d44de5d9bb/135ae/post3_eq1.png\" alt style=\"position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;object-position:center;opacity:1;transition:opacity 0.5s\"></picture><noscript><picture><img sizes=\"(max-width: 300px) 100vw, 300px\" srcset=\"/static/eeebed5885129f74716619d44de5d9bb/c14e1/post3_eq1.png 75w,\n/static/eeebed5885129f74716619d44de5d9bb/d4214/post3_eq1.png 150w,\n/static/eeebed5885129f74716619d44de5d9bb/135ae/post3_eq1.png 300w,\n/static/eeebed5885129f74716619d44de5d9bb/44727/post3_eq1.png 450w,\n/static/eeebed5885129f74716619d44de5d9bb/34e8a/post3_eq1.png 600w,\n/static/eeebed5885129f74716619d44de5d9bb/576cc/post3_eq1.png 896w\" src=\"/static/eeebed5885129f74716619d44de5d9bb/135ae/post3_eq1.png\" alt=\"\" style=\"position:absolute;top:0;left:0;transition:opacity 0.5s;transition-delay:0.5s;opacity:1;width:100%;height:100%;object-fit:cover;object-position:center\"/></picture></noscript></div><br>\nWhere P(d) is the cumulative percentage passing a sieve with aperture diameter d, dmax is the maximum size of aggregates and n is a constant n=0.45-0.70, respectively.<p></p>\n<p>The area representation of particles A_agg in each sieve size [d_i, d_i+1}] is [2]<br>\n</p><div class=\" gatsby-image-wrapper\" style=\"position:relative;overflow:hidden;max-width:100%;width:300px\" data-reactroot><div style=\"width:100%;padding-bottom:8.911739502999144%\"></div><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMABJPgAAST4AGIAg1vAAAATElEQVQI113MzQpAUBRF4Z3EdSUiXWZ+3v8draM94dTXmeyWJGVU/h1aXNgwouDGhBqDNyHpe9F4BzHsPZhxYHdwwYnVm+x4BJtfMD2iXwHsbLfiKQAAAABJRU5ErkJggg==\" alt style=\"position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;object-position:center;opacity:1;transition:opacity 0.5s;transition-delay:0.25s\"><picture><img sizes=\"(max-width: 300px) 100vw, 300px\" srcset=\"/static/3a86642b03a00e855fa19cc4ca0ef925/c14e1/post3_eq2.png 75w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/d4214/post3_eq2.png 150w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/135ae/post3_eq2.png 300w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/44727/post3_eq2.png 450w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/34e8a/post3_eq2.png 600w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/fea0e/post3_eq2.png 900w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/08b37/post3_eq2.png 1167w\" src=\"/static/3a86642b03a00e855fa19cc4ca0ef925/135ae/post3_eq2.png\" alt style=\"position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;object-position:center;opacity:1;transition:opacity 0.5s\"></picture><noscript><picture><img sizes=\"(max-width: 300px) 100vw, 300px\" srcset=\"/static/3a86642b03a00e855fa19cc4ca0ef925/c14e1/post3_eq2.png 75w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/d4214/post3_eq2.png 150w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/135ae/post3_eq2.png 300w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/44727/post3_eq2.png 450w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/34e8a/post3_eq2.png 600w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/fea0e/post3_eq2.png 900w,\n/static/3a86642b03a00e855fa19cc4ca0ef925/08b37/post3_eq2.png 1167w\" src=\"/static/3a86642b03a00e855fa19cc4ca0ef925/135ae/post3_eq2.png\" alt=\"\" style=\"position:absolute;top:0;left:0;transition:opacity 0.5s;transition-delay:0.5s;opacity:1;width:100%;height:100%;object-fit:cover;object-position:center\"/></picture></noscript></div><p></p>\n<p>Where d_max, d_min is the maximum and minimum size of aggregates, P_agg is the area fraction of all aggregates with respect to the total area of concrete sample A.</p>\n<p>The aggregates generally occupy 60-80% in volume for concrete [3]. For normal strength concrete, coarse aggregates usually represent 40-50% of concrete volume [1]. In this article, the approach by [3] is adopted. Aggregates larger than 2.36mm are modelled and smaller fine particles with cement is treated as mortar. Pore size range between 2-4mm diameter is considered here with a 2% total pore area. The sieve size distribution adapted from [3] is given in Table 1 and illustrated in Figure 1.</p>\n<p>Table 1. Four segment gradation of aggregate size distribution (Wang et al, 2015)</p>\n<table style=\"height: 242px;\" width=\"434\">\n<tbody>\n<tr>\n<td width=\"159\">Sieve Size (mm)</td>\n<td width=\"208\">Total Percentage Passing (%)</td>\n</tr>\n<tr>\n<td width=\"159\">19.00</td>\n<td width=\"208\">100</td>\n</tr>\n<tr>\n<td width=\"159\">12.70</td>\n<td width=\"208\">97</td>\n</tr>\n<tr>\n<td width=\"159\">9.50</td>\n<td width=\"208\">61</td>\n</tr>\n<tr>\n<td width=\"159\">4.75</td>\n<td width=\"208\">10</td>\n</tr>\n<tr>\n<td width=\"159\">2.36</td>\n<td width=\"208\">1.4</td>\n</tr>\n</tbody>\n</table>\n<h4>Aggregate and pore generation</h4>\n<p>The common aggregate/pore generation procedure is to generate and place the aggregates and pores in a repeated manner until the target area is fully packed. I will explain the detailed procedure for circular aggregates alongside python code for implementation.</p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li>Define input parameters such as circular aggregate gradation diameter ranges, pore size range, total coarse aggregate area, aggregate area for each gradation and total concrete area.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers\" data-line=\"all\"><code class=\"language-python\">\nheight = 0.1 #m\nlength = 0.1\nd0 = 0.002\nd1 = 0.004\npore_content = 0.02 #%\nminbound = 0.005</code></pre>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li>Generate a pore with a random x and y coordinate and random pore size from the pore size range.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers\" data-line=\"all\"><code class=\"language-python\">def generateCirclePores(length, height, d0, d1, pore_content, minbound):\n\t#length and height is the dimension of the generation area\n\t#d0 is min pore diameter, d1 is max pore diameter\n\t#pore content is pore % of total area\n\t#minbound is the distance away from side boundaries\n\tporeArea = pore_content*length*height\n\ttotalPoreArea = 0\n\tporeXvalues = []\n\tporeYvalues = []\n\tporeRvalues = []\n\twhile totalPoreArea &lt;= poreArea:\n\t\tr = (d0+random.random()*(d1-d0))/2\n\t\tboundary = minbound + r\n\t\tx = boundary + random.random()*(length-2*boundary)\n\t\ty = boundary + random.random()*(height-2*boundary)</code></pre>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li>Check if the pore generated is (1) Inside the concrete area (2) Does not overlap or intersect with existing pores by checking the distance between the pore centres and the sum of the two radii. If generated pore satisfies conditions, append pore parameters into an array.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers\" data-line=\"all\"><code class=\"language-python\">if len(poreXvalues) == 0:\n\t\t\tporeXvalues.append(x)\n\t\t\tporeYvalues.append(y)\n\t\t\tporeRvalues.append(r)\n\t\t\ttotalPoreArea = totalPoreArea + np.pi*r**2\n\t\telse: #check conditions\n\t\t\tdistance = np.asarray([(x-x1)**2+(y-y1)**2  for x1,y1 in zip(poreXvalues,poreYvalues)])\n\t\t\tminDistance = np.asarray([(2*(r+r1))**2 for r1 in poreRvalues])\n\t\t\tif np.any(distance &lt; minDistance):\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tporeXvalues.append(x)\n\t\t\t\tporeYvalues.append(y)\n\t\t\t\tporeRvalues.append(r)\n\t\t\t\ttotalPoreArea = totalPoreArea + np.pi*r**2\n\tprint(&quot;Total pore area is {} and error is {}%&quot;.format(totalPoreArea,(totalPoreArea-poreArea)*100/poreArea))\n\treturn poreXvalues, poreYvalues, poreRvalues\n</code></pre>\n<p>&#xA0;</p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li>Loop through steps 3 and 4 until the area of the pore remaining to be generated exceeds 2% of the total area.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers\" data-line=\"all\"><code class=\"language-python\">[poreX, poreY, poreR] = generateCirclesPores(length, height, d0, d1, pore_content, minbound)</code></pre>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li>Generate an aggregate with random x, y coordinate and starting with the largest random aggregate size from the gradation segment.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers\" data-line=\"all\"><code class=\"language-python\">aggVol = 0.3 #%\nsieveMax = [0.019, 0.0127,0.0095,0.00475] #m\nsieveMin = [0.0127,0.0095,0.00475,0.00236] #m\ncumPass = [1, 0.97, 0.61, 0.10, 0.014]\nitz = 0.0025\ndef generateCirclesWithPores(length, height, minbound, poreX,poreY,poreR, aggVol, sieveMin, sieveMax, cumPass, itz):\n    #length and height is the dimension of the generation area\n    #minbound is the distance away from side boundaries\n    #aggVol is volume/area of coarse aggregate in decimal i.e 0.5\n    #sieveMin is the min sieve sizes ordered from largest to smallest in list format\n    #sieveMax is the max sieve sizes ordered from largest to smallest in list format\n    #cumPass is the passing percentage in decimal for each sieve size from largest to smallest in list format\n    #itz is interfacial transition zone thickness in metres\n    area = length*height\n    Pmax = cumPass[0]\n    Pmin = cumPass[-1]\n    aggArea = [(cumPass[i]-cumPass[i+1])/(Pmax-Pmin)*aggVol*area for i in range(len(cumPass)) if i!=len(cumPass)-1]\n    #initalise lists\n    aggX = []\n    aggY = []\n    aggR = []\n    aggRitz = []\n    for sMin, sMax, gradeArea in zip(sieveMin, sieveMax, aggArea):\n        totalAggArea = 0\n        breakCount = 0\n        while totalAggArea &lt; gradeArea: if breakCount &gt;2**20:\n                break\n            r = (sMin+random.random()*(sMax-sMin))/2\n            r_itz = r+itz;\n            boundary = minbound + r_itz\n            x = boundary + random.random()*(length-2*boundary)\n            y = boundary + random.random()*(height-2*boundary)\n</code></pre>\n<p>&#xA0;</p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li>Check if the aggregate generated is (1) Inside the concrete area (2) Does not overlap/intersect with existing pores or aggregates (3) Has a minimum distance away from the boundaries (4)Has a minimum distance between aggregates and pores. When all conditions are satisfied, the aggregate parameters are appended to an array.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers\" data-line=\"all\"><code class=\"language-python\">\n#check not overlapping with pores\n            distance = np.asarray([(x-x1)**2+(y-y1)**2  for x1,y1 in zip(poreX,poreY)])\n            minDistance = np.asarray([(r_itz+r1)**2 for r1 in poreR])\n            if np.any(distance &lt; minDistance):\n                breakCount = breakCount +1\n                continue\n            if len(aggX) ==0:\n                aggX.append(x)\n                aggY.append(y)\n                aggR.append(r)\n                aggRitz.append(r_itz)\n                totalAggArea = totalAggArea + np.pi*r**2\n            else:\n                #check not overlapping with existing aggregates\n                distance = np.asarray([(x-x1)**2+(y-y1)**2  for x1,y1 in zip(aggX,aggY)])\n                minDistance = np.asarray([(r_itz+r1)**2 for r1 in aggR])\n                if np.any(distance &lt; minDistance):\n                    breakCount = breakCount +1\n                    continue\n                else:\n                    aggX.append(x)\n                    aggY.append(y)\n                    aggR.append(r)\n                    aggRitz.append(r_itz)\n                    totalAggArea = totalAggArea + np.pi*r**2\n        print(&quot;Reached agg size: {}&quot;.format(sMax))\n        print(&quot;Agg Area: {}, error is {}% &quot;.format(totalAggArea, (totalAggArea-gradeArea)*100/gradeArea))\n    return aggX, aggY, aggR, aggRitz\n</code></pre>\n<p>&#xA0;</p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li>Loop through step 5 and 6 until the aggregate area for the largest aggregate gradation exceeds the gradation area limit. Once exceeded, the generation of aggregate size will move on to the next gradation size and steps 5 and 6 are repeated with a different area limit.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers\" data-line=\"all\"><code class=\"language-python\">\n[aggX, aggY, aggR, aggRitz] = generateCirclesWithPores(length,height,minbound,poreX,poreY,poreR,aggVol,sieveMin, sieveMax, cumPass, itz)\n</code></pre>\n<p>&#xA0;</p>\n<p>To visual the generation of circular aggregates, the list of stored aggregate/pore values will be extracted and plotted in a chart.</p>\n<pre class=\"line-numbers\" data-line=\"all\"><code class=\"language-python\">\ndef plotCircles(X,Y,R,xrange,yrange):\n    fig, ax = plt.subplots()\n    ax.set_xlim((0, xrange))\n    ax.set_ylim((0, yrange))\n    for x,y,r in zip(X,Y,R):\n        circles = plt.Circle([x,y],r,color=&apos;red&apos;, fill=False)\n        ax.add_artist(circles)\n\tplt.show()\n\nplotCircles(poreX,poreY,poreR,length,height)\nplotCircles(aggX,aggY,aggR,length,height)\n</code></pre>\n<p style=\"text-align: left;\">So there you have it, I have demonstrated a brute force algorithm for circular aggregate generation. I hope this introductory overview provides you with the foundation to conduct more advanced mesoscale modelling. Of course, there is a still a crucial aspect that is missing, which is conducting mesoscale modelling through finite element software. This aspect of mesoscale modelling is something I will discuss later.</p>\n<h4>References</h4>\n<p>[1] Wriggers, P., Moftah, S.O., 2006, Mesoscale models for concrete: homogenisation and damage behaviour, Finite Element Analysis and Design, 42 (7), 623-636</p>\n<p>[2] Wang, Z., Kwan, A., Chan, H., 1999, Mesoscopic study of concrete I: generation of random aggregate structure and finite element mesh, Computers &amp; Structures, 70 (5), 533-544</p>\n<p>[3] Wang, X.F., Yang, Z.J., Yates, J.R., Jivkov, A.P., Zhang, Ch., 2015, Monte carlo simulations of mesoscale fracture modelling of concrete with random aggregates and pores, Construction and Building Materials, 75, 35-45</p>\n</body></html>","date":"2019-05-11T09:14:00.000Z","slug":"generation-of-random-circular-aggregates-for-mesoscale-modelling","acf":{"readingDuration":"10 min","gist_text":null},"categories":[{"name":"Article"}],"featured_media":{"localFile":{"childImageSharp":{"fluid":{"src":"/static/7496b7b2122fbe2416d3b4f87f3dfc9b/c2a4f/generationcircularaggregatescover-01.png"}}}}},"site":{"siteMetadata":{"title":"JOHN PHUNG","description":"Researcher, Designer, Developer & Entrepreneur","author":"John Phung","url":"https://johnphung.tech","twitterHandle":"@jphungme"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"ea197f6b-8964-59c8-b686-98b4a470d14f"}}